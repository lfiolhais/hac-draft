[[runtime]]
== HAC Programmer's Model

The HAC extension adds up to 32 HAC registers, and x unpriviliged CSRs to a
base scalar RISC-V ISA.

=== HAC Registers

The HAC extension adds up to 32 HAC registers to a base scalar RISC-V ISA.

Each HAC register has a fixed `HLEN` bits of state.

=== HAC Context Status in `mstatus`

A HAC context status field, `HACS`, is added to `mstatus[XX:YY]` and shadowed
in `sstatus[XX:YY]`. It is defined analogously to the floating-point and vector
context status fields, `FS` and `VS`.

Attempts to execute any HAC instruction, or to access the HAC CSRs, raise
an illegal-instruction exception when `mstatus.HACS` is set to Off.

When `mstatus.HACS` is set to Initial or Clean, executing any instruction that
changes HAC state, including the HAC CSRs, will change `mstatus.HACS` to Dirty.
Implementations may also change mstatus.HACS from Initial or Clean to Dirty at
any time, even when there is no change in HAC state.

If `mstatus.HACS` is Dirty, `mstatus.SD` is 1; otherwise, `mstatus.SD` is set
in accordance with existing specifications.

Implementations may have a writable `misa.HAC` field. Analogous to the way in
which the floating-point and vector unit are handled, the `mstatus.HACS` field
may exist even if `misa.HAC` is clear.

=== HAC Context Status in `vsstatus`

When the hypervisor extension is present, a HAC context status field, `HACS`,
is added to `vsstatus[XX:YY]`. It is defined analogously to the floating-point
and vector context status fields, `FS` and `VS`.

When V=1, both `vsstatus.HACS` and `mstatus.HACS` are in effect: attempts to
execute any HAC instruction, or to access the HAC CSRs, raise an
illegal-instruction exception when either field is set to Off.

When V=1 and neither `vsstatus.HACS` nor `mstatus.HACS` is set to Off,
executing any instruction that changes HAC state, including the HAC CSRs, will
change both `mstatus.HACS` and `vsstatus.HACS` to Dirty. Implementations may
also change `mstatus.HACS` or `vsstatus.HACS` from Initial or Clean to Dirty at
any time, even when there is no change in vector state.

If `vsstatus.HACS` is Dirty, `vsstatus.SD` is 1; otherwise, `vsstatus.SD` is
set in accordance with existing specifications.

If `mstatus.HACS` is Dirty, `mstatus.SD` is 1; otherwise, `mstatus.SD` is set
in accordance with existing specifications.

For implementations with a writable misa.HAC field, the `vsstatus.HACS` field
may exist even if `misa.HAC` is clear.

=== HAC Runtime (`mhacr`) Register

HAC allows SCCs of different sizes to be loaded into the register file. The
size of an SCC is not known at compile-time and has to be obtained at runtime
by reading the metadata of the SCC. It is possible for an SCC to use more than
one register. For example, asymmetric and symmetric cryptography use keys with
different sizes where symmetric are a fraction of the size of asymmetric keys.
The main goal of register grouping is to allow software portability across
different implementations. A register group is referred to as _HAC_ _register_
_group_. Analogously to the vector extension, _LMUL_, is used to refer to the
number of HAC registers that are combined to form an HAC register group.
Implementations must implement support for an LMUL value of 1, 2, and 4.
Implementations with 16 registers in the HAC register file must also implement
an LMUL value of 8. Implementations with 32 registers in the HAC file must also
implement an LMUL value of 8 and 16.

The WARL XLEN-wide HAC Runtime CSR, `mhacr` provides an interface for software
to interpret and manage the SCC allocations in the register file at machine-level.

Each SCC must use a power of two HAC registers. When an SCC allocates more than
one register, they must be contiguous. HAC register groups can't wraparound.

The `mhacr` register contains a slot, `hacmulN` and `hacmulN_valid`, for each
HAC register, which indicates how many registers an operand is using and the
validity of the register, respectively.

.hacmul[2:0] encoding
[cols="1,1,1,1"]
[%autowidth,float="center",align="center",options="header"]
|===
3+| hacmul[2:0] |   LMUL |  HLMAX  | Registers grouped with __n__

  | 0 | 0 | 0   |      1 |    HLEN |  `h` __n__ (single register in group)
  | 0 | 0 | 1   |      2 |  2*HLEN |  `h` __n__, `h` __n__+1
  | 0 | 1 | 0   |      4 |  4*HLEN |  `h` __n__, ..., `h` __n__+3
  | 0 | 1 | 1   |      8 |  8*HLEN |  `h` __n__, ..., `h` __n__+7
  | 1 | X | X   |      - |       - | Reserved
|===

[NOTE]
====
The architecture deliberately disallows the same HAC register to be used by two
or more SCCs --- i.e., fractional LMULs. The main rationale for this decision
is to reduce the complexity of the software that manages the `mhacr` and
simplify the slot encoding.
====

When LMUL=2, the HAC register group contains HAC register `h` __n__ and HAC
register `h` __n__+1, providing twice the HAC length in bits.  Instructions
specifying an LMUL=2 HAC register group with an odd-numbered HAC register are
reserved.

When LMUL=4, the HAC register group contains four HAC registers, and
instructions specifying an LMUL=4 HAC register group using HAC register numbers
that are not multiples of four are reserved.

When LMUL=8, the HAC register group contains eight HAC registers, and
instructions specifying an LMUL=8 HAC register group using register numbers
that are not multiples of eight are reserved.

[wavedrom,,svg]
....
{reg: [
  {bits: 1, name: 'hacmul0_valid'},
  {bits: 3, name: 'hacmul0'},
  {bits: 1, name: 'hacmul2_valid'},
  {bits: 3, name: 'hacmul2'},
  {bits: 1, name: 'hacmul4_valid'},
  {bits: 3, name: 'hacmul4'},
  {bits: 1, name: 'hacmul6_valid'},
  {bits: 3, name: 'hacmul6'},
  {bits: 1, name: 'hacmul8_valid'},
  {bits: 3, name: 'hacmul8'},
  {bits: 1, name: 'hacmul10_valid'},
  {bits: 3, name: 'hacmul10'},
  {bits: 1, name: 'hacmul12_valid'},
  {bits: 3, name: 'hacmul12'},
  {bits: 1, name: 'hacmul14_valid'},
  {bits: 3, name: 'hacmul14'},

  {bits: 1, name: 'hacmul16_valid'},
  {bits: 3, name: 'hacmul16'},
  {bits: 1, name: 'hacmul18_valid'},
  {bits: 3, name: 'hacmul18'},
  {bits: 1, name: 'hacmul20_valid'},
  {bits: 3, name: 'hacmul20'},
  {bits: 1, name: 'hacmul22_valid'},
  {bits: 3, name: 'hacmul22'},
  {bits: 1, name: 'hacmul24_valid'},
  {bits: 3, name: 'hacmul24'},
  {bits: 1, name: 'hacmul26_valid'},
  {bits: 3, name: 'hacmul26'},
  {bits: 1, name: 'hacmul28_valid'},
  {bits: 3, name: 'hacmul28'},
  {bits: 1, name: 'hacmul30_valid'},
  {bits: 3, name: 'hacmul30'},

  {bits: 1, name: 'hacmul1_valid'},
  {bits: 1, name: 'hacmul3_valid'},
  {bits: 1, name: 'hacmul5_valid'},
  {bits: 1, name: 'hacmul7_valid'},
  {bits: 1, name: 'hacmul9_valid'},
  {bits: 1, name: 'hacmul11_valid'},
  {bits: 1, name: 'hacmul13_valid'},
  {bits: 1, name: 'hacmul15_valid'},
  {bits: 1, name: 'hacmul17_valid'},
  {bits: 1, name: 'hacmul19_valid'},
  {bits: 1, name: 'hacmul21_valid'},
  {bits: 1, name: 'hacmul23_valid'},
  {bits: 1, name: 'hacmul25_valid'},
  {bits: 1, name: 'hacmul27_valid'},
  {bits: 1, name: 'hacmul29_valid'},
]}
....

An HAC implementation with 8 registers, only has access to even numbered
register IDs. Moreover, for the same implementation, slot `hacmul14` and all
odd numbered slots are WPRI.

The slots `hacmul[24-30]` have the LMUL=8 encoding reserved. The slot
`hacmul[28-30]` has the LMUL=4 encoding reserved. The slot `hacmul30` has the
LMUL=2 encoding reserved.

The validity of a HAC register group is always given by the least significant
`hacmul` ID. The remaining bits in the slots of the HAC register group are
don't care.

When `hacmulN_valid` is 0, all encodings in the corresponding `hacmulN` are
reserved.

=== Context Transport Key

The Context Transport Key (CTK) is always stored in the `H` register with the
highest ID --- `H7`, `H15`, or `H31`. The CTK can only be modified in effective
privilege mode M. Attempting to decode an HAC instruction which modifies the
CTK outside of effective privilege mode M results in an exception with code
"Illegal Instruction". A CTK is loaded using a dedicated set or import
instruction. The CTK register may ignore writes, and follows the WARL behavior.

[NOTE]
====
Writes may be ignored in the CTK register such that smaller implementations can
hardcode a key.
====

[NOTE]
====
CTK is encoded in an HAC register instead of a CSR because its width is larger
than XLEN.
====

Import and export operations to other HAC registers use the currently loaded
CTK to import and export data in each register. Registers loaded under a CTK X
can only be used when CTK X is loaded. Attempting to use a register with a
different CTK Y results in an exception with code "Illegal Instruction".

