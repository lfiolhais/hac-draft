[[intro]]
== Introduction

Cryptographic operations are high-value targets for attackers that seek to
extract sensitive data from a system. In RISC-V, such operations are performed
using standard instructions, such as scalar or vector operations, which are
susceptible to a set of side-channel attacks. In order to protect
implementations that make use such instructions, obfuscation techniques can be
applied at the software or hardware level. Providing obfuscation at the
hardware level would make the code targetting such hardware non-portable, and
providing obfuscation at the software level results in performance degradation.

To tackle this problem, application-class computer architectures provide a
performant and high assurance cryptographic engine. The engine ususally resides
in the Root-of-Trust (RoT), outside the application processors (APs), and it
has a bespoke interface that is vendor or microarchitecture specific. Despite
meeting the security goals, the software used to program such an engine is
specific to the target. Further, performance gains may be small because of the
communication cost between the AP and the RoT. For server-class architectures,
these accelerators are tightly coupled to the APs to ensure high-performance,
but, once again, they require non-portable code.

This document describes the High Assurance Cryptography (HAC) extension for
RISC-V. The goal of the extension is to provide a standardized architectural
interface for cryptographic operations that need to be executed with high
assurance guarantees, e.g., data can't be retrieved through side-channels,
while maintaining high performance.

The HAC extension defines a new register file which holds secure cryptographic
contexts (SCCs). Registers in the HAC extension are referred to as `H`
registers. Accesses to HAC contexts can only be performed through HAC
instructions. Data can be moved in and out of the register file using HAC's
import and export instructions --- they are analagous to the standard RISC-V's
loads and stores. Data that is exported from the register file is encrypted
using a context transport key (CTK). The import operation decrypts the data,
using the same CTK, and stores it in a given register. Registers can also be
loaded using a set instruction. The set instruction performs the same operation
as import without the need to decrypt the data, i.e., the data loaded is in
plaintext. Each register can have a width of 128, 256, or 512 bits. The
register width is referred to as `HLEN`. All registers have the same width. The
HAC register file can have 8, 16, or 32 registers.

[NOTE]
====
The term "register file" is used as a means to refer to a hart's private
memory. A register file implementation is not mandated to use a particular
memory primitive. Implementors are free to choose the memory primitive that
better fits their goals.
====

[NOTE]
====
Different widths of registers and number of registers are provided to offer
flexibility in implementations. Server-class architectures will want to perform
multiple cryptographic operations without paying for the import and export
latency --- e.g., content delivery networks, cloud providers, etc. ---, whereas
application-class or microcontroller-class architectures provide a smaller set
of register for occasional usage --- e.g., connecting to websites, accessing
encrypted storage, etc.
====

All instructions described herein use the HAC registers, and obey the
2-read-1-write register access constraint. Most HAC instructions provide Zkt
guarantees.

[[policies]]
=== Policies
In creating this proposal, we tried to adhere to the same policies as the other
cryptograhic extensions, they are:

* The extension will be designed to support _existing_ standardised
  cryptographic constructs well. It will not try to support proposed standards,
  or cryptographic constructs which exist only in academia. Cryptographic
  standards which are settled upon concurrently with or after the RISC-V
  cryptographic extension standardisation will be dealt with by future
  additions to, or versions of, the RISC-V HAC extension.

* Historically, there has been some discussion cite:[LSYRR:04] on how newly
  supported operations in general-purpose computing might enable new bases for
  cryptographic algorithms. The standard will not try to anticipate new useful
  low-level operations which _may_ be useful as building blocks for future
  cryptographic constructs.


